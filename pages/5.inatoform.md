---
layout: center
---

# üì£ Announcing `@inato-form` üéâ

### An open source library to simplify the form experience

<v-click>

### Powered by Effect and Schema ‚Ñ¢Ô∏è

</v-click>

<!--
Mesdames et messieurs, j'ai le plaisir de vous annoncer que ce monde n'est pas imaginaire!

Vous pouvez d√©sormais utiliser la librarie `@inato-form` pour √©crire vos prochains formulaires!

[click] Tout √ßa grace √† Effect et Schema!
-->

---
layout: center
---

```tsx {*|1,2,8-13|3-6,15-18|6,20-24|*}{lines:true}
import { FormBody, FormDisplay } from "@inato-form/core"
import { TextInput, MultiSelect } from "@inato-form/fields"
import { ReactHookForm } from "@inato-form/react-hook-form"
import { MantineFields } from "@inato-form/mantine"
import { Button } from "@mantine/core"
import { Layer, Effect } from "effect"

const definition = FormBody.struct({
  firstName: TextInput.Required,
  lastName: TextInput.Optional,
  email: TextInput.Email.Required,
  favorite: MultiSelect.Default("React", "Angular", "Vue", "Svelte"),
});

const FormLive = Layer.provideMerge(
  MantineFields.layer,
  ReactHookForm.layer(Mantine.Button)
);

export const display = pipe(
  FormDisplay.make(definition),
  Effect.provide(FormLive),
  Effect.runSync
);
```

<style>
.slidev-code-wrapper {
  max-height: unset;
  overflow-y: scroll;
}
</style>

<!--
This is what it looks like with @inato-form

[click] You can get everything you need for the definition out of  `core` and `fields` packages.

[click] We also have `mantine` and `react-hook-form` packages to create the layer we need.

[click] Finally we use effect runSync to create the display.
-->

<!--
Voici √† quoi √ßa ressemble en utilisant `@inato-form`

[click] On r√©cup√®re tout ce dont on a besoin pour la definition du formulaire dans les packages `core` et `fields`.

[click] Pour l'injection de d√©pendance, on fait appel aux packages `mantine` et `react-hook-form`

[click] Et enfin on utilise Effect runSync pour cr√©er cet objet display.

Le reste ne change pas.
-->

---

# What have we gained?
<br>

<v-click>
üëå Simpler fields with combined <span v-mark.underline.green="2">schema</span> and <span v-mark.underline.orange="2">UI</span> definition in one place: <code><span v-mark.underline.orange="2">TextInput</span>.<span v-mark.underline.green="2">Required</span></code>
</v-click>

<v-clicks at="3">

üßëüèº‚Äçüíª Lower cognitive load: `Form` component is more about aesthetics, less about mechanics

‚è© Standardization: use existing form fields to build your forms

üîß Composability: reuse common definition building blocks in different forms

‚ö°Ô∏è Dependency injection: the choice of external libraries is extracted away

üîÅ Dry: use `definition.schema` server side to decode API requests

‚ôªÔ∏è Intellisense: `<display.firstName />` vs `<TextInput name="firstName" />`

</v-clicks>

<style>
code {
    font-size: 0.9em;
    background: var(--slidev-code-background);
    border-radius: var(--slidev-code-radius);
    padding-top: 0.125rem;
    padding-bottom: 0.125rem;
    padding-left: 0.375rem;
    padding-right: 0.375rem;
    font-weight: 300;
}
</style>

<!--
Qu'a t on gagn√© dans tout √ßa? 

[click] La d√©finition de la structure du formulaire est simplifi√©e parce qu'on a combin√© la validation et l'UI de chaque champ en un seul objet
[click]

[click] Notre composant `Form` est beaucoup plus clean: que de l'esth√©tique, pas de m√©canique. La charge cognitive est plus failble.

[click] Pas besoin de d√©marrer from scratch √† chaque nouveau formulaire: on peut directement utiliser les champs d√©j√† pr√©vus √† cet effet.

[click] On peut facilement r√©utiliser des bloques de formulaires pour les partager √† diff√©rents endroits

[click] Grace √† l'injection de d√©pendance, le choix des librairies externes est secondaire

[click] On peut facilement extraire le schema de l'objet definition pour l'utiliser cot√© server. √Ä ce stade on n'a pas encore inject√© de librarie frontend type Mantine ou react hook form donc on peut tout √† fait importer cet objet cot√© backend.

[click] On a egalement une meilleure experience dans l'√©diteur. Avant on manipulait des strings dans les composants. Maintenant on manipule des objets. On peut donc utiliser les features de VSCode comme "go to", "find all references" ou meme "rename symbol"
-->

---

# How it works
Pseudo code

````md magic-move

```tsx
TextInput ~ Context<"TextInput",React.FC<Props>>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = framework.register(yield* field, key)
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = framework.register(yield* field, key)
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [Mantine, ReactHookForm]) // Effect<{ firstName: React.FC<Props> }>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = framework.register(yield* field, key)
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [AntD, TanStackForm]) // Effect<{ firstName: React.FC<Props> }>
```

```tsx
TextInput.Required ~ [Schema<NonEmptyString>, Context<"TextInput",React.FC<Props>>]

FormBody.struct({ firstName: TextInput.Required }) 
  ~ [Schema.Struct<{firstName: Schema<NonEmptyString>}>, { firstName: Context<"TextInput",React.FC<Props>> }]

FormDisplay.make = (definition) => 
  Effect.gen(function*() {
    const framework = yield* FormFramework
    const result = {}
    for(const [key, field] of definition) {
      result[key] = framework.register(yield* field, key)
    }
    return result
  }) // Effect<{ firstName: React.FC<Props> }, never, TextInput | FormFramework>

Effect.provide(display, [Shadcn, MantineForm]) // Effect<{ firstName: React.FC<Props> }>
```
````

<!--
Alors comment √ßa marche tout √ßa?

Je vais vous donner les grandes lignes, en pseudo code.

Tout d'abord un Field c'est quoi? C'est grosso modo un Context Effect dont le service est un composant react

[click] On parle ensuite de variante (required, optional etc..) d'un Field. C'est juste un couple Schema Context

[click] On creer la definition du formulaire via un struct et √ßa qu'est-ce que √ßa fait? √áa cr√©e juste un couple Schema, objet comme cela

[click] Ensuite, pour creer le display, on utilise la methode make et l'algorithme ressemble tres grossierement √† √ßa. On commence par r√©cup√©rer un framework de formulaire puis on it√®re sur chaque propri√©t√© de la definition en d√©l√©gant au framework la tache d'enregistrement du composant.

Apres tout √ßa ce qu'on r√©cup√®re c'est un Effect qui a des d√©pendances.

[click] Puis on provide ces d√©pendances via Effect 

[click] On peut facilement changer les d√©pendances sans jamais alt√©rer le type de l'objet en retour.
-->
